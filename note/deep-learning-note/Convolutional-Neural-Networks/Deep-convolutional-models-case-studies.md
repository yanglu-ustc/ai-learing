# Deep convolutional models: case studies

## 1. 经典网络(Classic networks)

### **LeNet-5**

**LeNet-5**可以识别图中的手写数字，是针对灰度图片训练的，所以图片的大小只有32×32×1。该LeNet模型总共包含了大约6万个参数，典型的LeNet-5结构包含CONV layer,POOL layer,FC layer，顺序一般是 $CONV\ layer\to POOL\ layer\to CONV\to POOL\to FC\ layer\to FC\to OUTPUT\ layer$，即 $\hat{y}$

随着网络越来越深，图像的高度和宽度在缩小，从最初的32×32缩小到28×28，再到14×14,10×10，最后只有5×5，通道数量一直在增加，从1增加到6个，再到16个

这个神经网络中还有一种模式就是一个或多个卷积层后面跟着一个池化层，然后又是若干个卷积层再接一个池化层，然后是全连接层，最后是输出。在全连接层使用的是sigmoid和tanh激活函数

<div align=center>
<img src="img/屏幕截图%202024-04-29%20185039.png" width=80%>
</div>

### **AlexNet**

**AlexNet**包含约6000万个参数。当用于训练图像和数据集时，**AlexNet**能够处理非常相似的基本构造模块，这些模块往往包含着大量的隐藏单元或数据，**AlexNet**比**LeNet**表现更为出色的另一个原因是它使用了**ReLu**激活函数

<div align=center>
<img src="img/屏幕截图%202024-04-29%20185840.png" width=80%>
</div>

### **VGG-16**

**VGG**，也叫作**VGG-16**网络。**VGG-16**网络没有那么多超参数，是一种只需要专注于构建卷积层的简单网络。首先用3×3，步幅为1的过滤器构建卷积层，**padding**参数为**same**卷积中的参数。然后用一个2×2，步幅为2的过滤器构建最大池化层。**VGG**网络的一大优点是简化了神经网络结构

假设要识别这个图像，在最开始的两层用64个3×3的过滤器对输入图像进行卷积，输出结果是224×224×64，因为使用了**same**卷积，通道数量也一样

接下来创建一个池化层，池化层将输入图像进行压缩，减少到112×112×64。然后又是若干个卷积层，使用128个过滤器，以及一些**same**卷积，输出112×112×128。然后进行池化，池化后的结果是56×56×128。再用256个相同的过滤器进行三次卷积操作，然后再池化，然后再卷积三次，再池化。如此进行几轮操作后，将最后得到的7×7×512的特征图进行全连接操作，得到4096个单元，然后进行**softmax**激活，输出从1000个对象中识别的结果

**VGG-16**的数字16指在这个网络中有13个卷积层和3个全链接层

总共包含约1.38亿个参数，这种网络结构很规整，都是几个卷积层后面跟着可以压缩图像大小的池化层，池化层缩小图像的高度和宽度。同时，卷积层的过滤器数量变化存在一定的规律，由64翻倍变成128，再到256和512。主要缺点是需要训练的特征数量非常巨大

随着网络的加深，图像的高度和宽度都在以一定的规律不断缩小，每次池化后刚好缩小一半，而通道数量在不断增加，而且刚好也是在每组卷积操作后增加一倍。即图像缩小的比例和通道数增加的比例是有规律的

<div align=center>
<img src="img/屏幕截图%202024-04-29%20192724.png" width=80%>
</div>

## 2. 残差网络(Residual Networks (ResNets))

人为地让神经网络某些层跳过下一层神经元的连接，隔层相连，弱化每层之间的强联系，这种神经网络被称为**Residual Networks(ResNets)**

Residual Networks由许多隔层相连的神经元子模块组成，称之为Residual block(残差块)。单个Residual block的结构如下图所示：

<div align=center>
<img src="img/屏幕截图%202024-04-29%20194113.png" width=47%>
<img src="img/屏幕截图%202024-04-29%20195657.png" width=48%>
</div>

紫色线是skip connection(跳跃连接)，直接建立 $a^{[l]}$ 与 $a^{[l+2]}$ 之间的隔层联系。相应的表达式如下:

$$
z^{[l+1]}=W^{[l+1]}\cdot a^{[l]}+b^{[l+1]}
$$

$$
a^{[l+1]}=g(z^{[l+1]})
$$

$$
z^{[l+2]}=W^{[l+2]}\cdot a^{[l+1]}+b^{[l+2]}
$$

$$
a^{[l+2]}=g(z^{[l+2]}+a^{[l]})
$$

$a^{[l]}$ 直接隔层与下一层的线性输出相连，$a^{[l]}$ 插入的时机是在线性激活之后，**ReLU**激活之前，与 $z^{[l+2]}$ 共同通过激活函数(ReLU)输出 $a^{[l+2]}$

这种模型结构对于训练非常深的神经网络效果很好。非Residual Networks称为Plain Network

与Plain Network相比，Residual Network能够训练更深层的神经网络，有效避免发生发生梯度消失和梯度爆炸

* 随着神经网络层数增加，Plain Network实际性能会变差，training error甚至会变大
* Residual Network的训练效果却很好，training error一直呈下降趋势

## 3. 残差网络为什么有用？(Why ResNets work?)

输入 $\bm{X}$ 经过一个大型神经网络输出激活值 $a^{[l]}$，再给这个网络额外添加两层作为一个ResNets块，输出 $a^{[l+2]}$:

$$
a^{[l+2]}=g(z^{[l+2]}+a^{[l]})=g(W^{[l+2]}\cdot a^{[l+1]}+b^{[l+2]}+a^{[l]})
$$

<div align=center>
<img src="img/屏幕截图%202024-04-29%20210222.png" width=47%>
<img src="img/屏幕截图%202024-04-29%20210255.png" width=47%>
</div>

> 假设在整个网络中使用ReLU激活函数，所以激活值都大于等于0，包括输入 $\bm{X}$ 的非零异常值。因为ReLU激活函数输出的数字要么是0，要么是正数
>
> 如果使用L2正则化或权重衰减，会压缩 $W^{[l+2]}$ 的值。$W$ 是关键项，如果 $W^{[l+2]}=0$，方便起见，假设 $b^{[l+2]}=0$，假定使用ReLU激活函数，并且所有激活值都是非负的，$g(a^{[l]})$ 是应用于非负数的ReLU函数，所以 $a^{[l+2]}=a^{[l]}$
>
> 可以看出，即使发生了梯度消失，$W^{[l+2]}\approx 0$，$b^{[l+2]}\approx 0$，也能直接建立 $a^{[l+2]}$ 与 $a^{[l]}$ 的线性关系，且 $a^{[l+2]}=a^{[l]}$，这就是identity function(恒等函数)。$a^{[l]}$ 直接连到 $a^{[l+2]}$，相当于直接忽略了 $a^{[l]}$ 之后的这两层神经层。这样看似很深的神经网络，由于许多Residual blocks的存在，弱化削减了某些神经层之间的联系，实现隔层线性传递，而不是一味追求非线性关系，模型本身也就能“容忍”更深层的神经网络了。从性能上来说，这两层额外的Residual blocks也不会降低Big NN的性能，所以给大型神经网络增加两层，不论是把残差块添加到神经网络的中间还是末端位置，都不会影响网络的表现
>
> 如果Residual blocks确实能训练得到非线性关系，那么也会忽略short cut，跟Plain Network起到同样的效果
>
> 如果Residual blocks中 $a^{[l+2]}$ 与 $a^{[l]}$ 的维度不同，可以引入矩阵 $\bm{W}_s$ 与 $a^{[l]}$ 相乘，使得 $\bm{W}_s\cdot a^{[l]}$ 的维度与 $a^{[l+2]}$ 一致

参数矩阵 $\bm{W}_s$ 有来两种方法得到：

* 将 $\bm{W}_s$ 作为学习参数，通过模型训练得到
* 固定 $\bm{W}_s$ 值(类似单位矩阵)，不需要训练，$\bm{W}_s$ 与 $a^{[l]}$ 的乘积仅使得 $a^{[l]}$ 截断或者补零

CNN中ResNets的结构：

ResNets同类型层之间，例如CONV layers，大多使用same类型，这也解释了添加项 $z^{[l+2]}+a^{[l]}$(维度相同所以能够相加)。如果是不同类型层之间的连接，例如CONV layer与POOL layer之间，如果维度不同，则引入矩阵 $\bm{W}_s$

### 说明：

* ResNets想表达的是减少激活函数的多层叠加导致的信息损失的问题。
* 使用ResNets相当于将矩阵之外多加了一个系数1，在信息损失巨大的时候可以将输入/输出进行跨层传输！！！！！

## 4. 网络中的网络以及 1×1 卷积(Network in Network and 1×1 convolutions)

如果是一张6×6×32的图片，使用1×1过滤器进行卷积效果更好。1×1卷积所实现的功能是遍历这36个单元格，计算左图中32个数字和过滤器中32个数字的元素积之和，然后应用ReLU非线性函数

1×1×32过滤器中的32个数字可以理解为一个神经元的输入是32个数字，这32个数字具有不同通道，乘以32个权重（将过滤器中的32个数理解为权重），然后应用ReLU非线性函数，输出相应的结果

如果过滤器是多个，就好像有多个输入单元，其输入内容为一个切片上所有数字，输出结果是 $6\times 6\times \#filters$

1×1卷积可以从根本上理解为对这32个不同的位置都应用一个全连接层，全连接层的作用是输入32个数字(过滤器数量标记为 $n_C^{[l+1]}$，在这36个单元上重复此过程),输出结果是 $6\times 6\times \#filters$(过滤器数量)，以便在输入层上实施一个非平凡(non-trivial)计算

这种方法通常称为1×1卷积，也被称为Network in Network

<div align=center>
<img src="img/屏幕截图%202024-04-29%20225808.png" width=47%>
<img src="img/屏幕截图%202024-04-30%20143158.png" width=47%>
</div>

> 假设一个28×28×192的输入层，如果通道数量很大，可以用32个大小为1×1×192的过滤器，使输出层为28×28×32，这就是压缩通道数($n_C$)的方法！！！！！！

如果想保持通道数192不变，也是可行的，1×1卷积只是添加了非线性函数，也可以让网络学习更复杂的函数

1×1卷积层给神经网络添加了一个非线性函数，从而减少或保持输入层中的通道数量不变，也可以增加通道数量

## 5 谷歌 Inception 网络简介（Inception network motivation）

Inception网络或Inception层的作用是代替人工来确定卷积层中的过滤器类型，或者确定是否需要创建卷积层或池化层

基本思想是Inception网络在单层网络上可以使用多个不同尺寸的filters，进行same convolutions，把各filter下得到的输出拼接起来。还可以将CONV layer与POOL layer混合，同时实现各种效果，但是要注意使用same pool。Inception Network不需要人为决定使用哪个过滤器或者是否需要池化，它使用不同尺寸的filters并将CONV和POOL混合起来，将所有功能输出组合拼接，再由神经网络本身去学习参数并选择最好的模块

<div align=center>
<img src="img/屏幕截图%202024-04-30%20144719.png" width=80%>
</div>

> Inception Network在提升性能的同时，会带来计算量大的问题:
>
> 乘法运算的总次数为每个输出值所需要执行的乘法运算次数(5×5×192)乘以输出值个数(28×28×32)，结果等于1.2亿。
>
> 为此，引入1x1 Convolutions来减少计算量，对于输入层，使用1×1卷积把输入值从192个通道减少到16个通道。然后对这个较小层运行5×5卷积，得到最终输出
>
> 把该1x1 Convolution称为“瓶颈层”(bottleneck layer)，瓶颈层是网络中最小的部分，即先缩小网络，然后再扩大
>
> 引入bottleneck layer之后，第一个卷积层计算成本:1×1×192×输出28×28×16，相乘结果约等于240万，第二个卷积层的计算成本是:28×28×32×5×5×16，计算结果为1000万，总次数是1204万，计算成本从1.2亿下降到了原来的十分之一
>
> <div align=center>
> <img src="img/屏幕截图%202024-04-30%20145358.png" width=47%>
> <img src="img/屏幕截图%202024-04-30%20145407.png" width=47%>
> </div>

总结:

* 如果在构建神经网络层的时候，不想决定池化层是使用1×1，3×3还是5×5的过滤器，Inception模块是最好的选择。可以应用各种类型的过滤器，只需要把输出连接起来
* 计算成本问题，通过使用1×1卷积来构建瓶颈层，大大降低计算成本

只要合理构建瓶颈层，既可以显著缩小表示层规模，又不会降低网络性能，从而节省了计算

## 6. Inception 网络(Inception network)

<div align=center>
<img src="img/屏幕截图%202024-04-30%20150002.png" width=45%>
<img src="img/屏幕截图%202024-04-30%20150020.png" width=45%>
</div>

#### 基本结构

引入1x1 Convolution后的Inception module如上左图所示

**Inception**模块会将之前层的激活或者输出作为它的输入，为了能在最后将这些输出都连接起来，会使用**same**类型的**padding**来池化，使得输出的高和宽依然是28×28，这样才能将它与其他输出连接起来。如果进行了最大池化，即便用了**same padding**，3×3的过滤器，**stride**为1，其输出将会是28×28×192，其通道数与输入(通道数)相同。要做的是再加上一个1×1的卷积层，将通道的数量缩小到28×28×32，避免了最后输出时，池化层占据所有的通道

最后把得到的各个层的通道都加起来，得到一个28×28×256的输出。这就是一个**Inception**模块

#### 完整的网络架构实现效果

> **Inception**网络只是很多在不同的位置重复组成的网络如上右图所示
>
> 中间隐藏层也可以作为输出层Softmax，确保了即便是隐藏单元和中间层也参与了特征计算，也能预测图片的分类，起到一种调整的效果，有利于防止发生过拟合
>
> 我们在不同的层输出不一样的结果，最终通过Softmax预测结果，将结果的预测值和实际值相比较，选择最为合适的神经网络深度(防止过拟合！！！！！！)

## 7. 迁移学习(Transfer Learning)

<div align=center>
<img src="img/屏幕截图%202024-04-30%20151923.png" width=40.5%>
<img src="img/屏幕截图%202024-04-30%20153506.png" width=58%>
</div>

训练集很小的情况:

建议:从网上下载一些神经网络开源的实现，不仅把代码下载下来，也把权重下载下来。然后去掉Softmax层，创建自己的Softmax单元，用来输出Tigger、Misty和neither三个类别。把所有的层看作是冻结的，冻结网络中所有层的参数，只需要训练和Softmax层有关的参数。这个Softmax层有三种可能的输出，Tigger、Misty或者Neither。

通过使用其他人预训练的权重，很可能得到很好的性能，即使只有一个小的数据集。大多数深度学习框架会有trainableParameter=0的参数，对于前面的层，可以设置这个参数。为了不训练这些权重，会有freeze=1的参数。只需要训练softmax层的权重，把前面这些层的权重都冻结

> 由于前面的层都冻结了，相当于一个固定的函数，因此不需要改变和训练它，取输入图像X，然后把它映射到softmax前一层的激活函数。能加速训练的技巧是如果先计算这一层(紫色箭头标记)，计算特征或者激活值，然后把它们存到硬盘里。所做的就是用这个固定的函数，在这个神经网络的前半部分(softmax层之前的所有层视为一个固定映射)，取任意输入图像X，然后计算它的某个特征向量，这样训练的就是一个很浅的softmax模型，用这个特征向量来做预测。对计算有用的一步就是对训练集中所有样本的这一层的激活值进行预计算，然后存储到硬盘里，在此之上训练softmax分类器。存储到硬盘或者说预计算方法的优点是不需要每次遍历训练集再重新计算这个激活值
>
> 总之就是:就相当于把这个激活值当作你的新样本，以后就用这些样本训练就行

更大的训练集:应该冻结更少的层，然后训练后面的层。如果输出层的类别不同，那么需要构建自己的输出单元，Tigger、Misty或者Neither三个类别。可以取后面几层的权重，用作初始化，然后从这里开始梯度下降

也可以直接去掉这几层，换成自己的隐藏单元和softmax输出层，如果有越来越多的数据，那么需要冻结的层数就越少，能够训练的层数就越多。如果有一个更大的数据集，那么不要单单训练一个softmax单元，而是考虑训练中等大小的网络，包含最终要用的网络的后面几层

如果有大量数据:应该做的就是用开源的网络和它的权重，把所有的权重当作初始化，然后训练整个网络

如果有越多的标定的数据，可以训练越多的层。极端情况下，可以用下载的权重只作为初始化，用它们来代替随机初始化，接着用梯度下降训练，更新网络所有层的所有权重

## 8. 数据扩充(Data augmentation)

当下计算机视觉的主要问题是没有办法得到充足的数据

<div align=center>
<img src="img/屏幕截图%202024-04-30%20152518.png" width=45%>
<img src="img/屏幕截图%202024-04-30%20152536.png" width=45%>
</div>

最简单的数据扩充方法就是 **垂直镜像对称**

另一个经常使用的技巧是 **随机裁剪**，给定一个数据集，然后开始随机裁剪，得到不同的图片放在数据集中，随机裁剪并不是一个完美的数据扩充的方法，如果随机裁剪的那一部分(红色方框标记部分，编号4)看起来不像猫。但在实践中，这个方法还是很实用的，随机裁剪构成了很大一部分的真实图片

也可以使用 **旋转，剪切(仅水平或垂直坐标发生变化)图像，扭曲变形，引入很多形式的局部弯曲** 等等，但在实践中太复杂所以使用的很少

**彩色转换:给R、G和B三个通道上加上不同的失真值**

实践中对R、G和B的变化是基于某些分布，改变可能很小，R、G和B的值是根据某种概率分布来决定，这样会使得学习算法对照片的颜色更改更具鲁棒性

对R、G和B有不同的采样方式，其中一种影响颜色失真的算法是 **PCA**，即主成分分析，PCA颜色增强的大概含义是，如果图片呈现紫色，即主要含有红色和蓝色，绿色很少，然后PCA颜色增强算法就会对红色和蓝色增减很多，绿色变化相对少一点，所以使总体的颜色保持一致

如果有特别大的训练数据，可以使用 **CPU线程**，不停的从硬盘中读取数据，用CPU线程来实现失真变形，可以是随机裁剪、颜色变化，或者是镜像

同时CPU线程持续加载数据，然后实现 **任意失真变形**，从而构成批数据或者最小批数据，这些数据持续的传输给其他线程或者其他的进程，然后开始训练，可以在CPU或者GPU上实现一个大型网络的训练

常用的实现数据扩充的方法是 **使用一个线程或者是多线程来加载数据，实现变形失真，然后传给其他的线程或者其他进程来训练，可以并行实现**

在数据扩充过程中也有一些 **超参数**，比如说颜色变化了多少，以及随机裁剪的时候使用的参数

## 9. 计算机视觉现状(The state of computer vision)

大部分机器学习问题是介于少量数据和大量数据范围之间的。

* 语音识别有很大数量的数据
* 虽然现在图像识别或图像分类方面有相当大的数据集，但因为图像识别是一个复杂的问题，通过分析像素并识别出它是什么，即使在线数据集非常大，如超过一百万张图片，仍然希望能有更多的数据
* 物体检测拥有的数据更少
* 图像识别是如何看图片的问题，并且告诉你这张图是不是猫，而对象检测则是看一幅图，画一个框，告诉你图片里的物体，比如汽车等等。因为获取边框的成本比标记对象的成本更高，所以进行对象检测的数据往往比图像识别数据要少

当有很多数据时，倾向于使用更简单的算法和更少的手工工程，只要有一个大型的神经网络，甚至一个更简单的架构，就可以去学习它想学习的东西

当没有那么多的数据时，更多的是手工工程

对机器学习应用时，通常学习算法有两种知识来源:

* 一个来源是被标记的数据，像 $(x,y)$ 应用在监督学习
* 第二个来源是手工工程，有很多方法去建立一个手工工程系统，它可以是源于精心设计的特征，手工精心设计的网络体系结构或者是系统的其他组件。当没有太多标签数据时，只需要更多地考虑手工工程

<div align=center>
<img src="img/屏幕截图%202024-04-30%20153147.png" width=45%>
<img src="img/屏幕截图%202024-04-30%20153218.png" width=45%>
</div>

在基准研究和比赛中，下面的tips可能会有较好的表现:

* 集成，意味着想好了要的神经网络之后，可以独立训练几个神经网络，并平均它们的输出。比如说随机初始化三个、五个或者七个神经网络，然后训练所有这些网络，对输出 $\hat{y}$ 进行平均计算，而不要平均权重，可能会在基准上提高1%，2%或者更好。但因为集成意味着要对每张图片进行测试，可能需要在从3到15个不同的网络中运行一个图像，会让运行时间变慢
* Multi-crop at test time，Multi-crop是一种将数据扩充应用到测试图像中的一种形式，在测试图片的多种版本上运行分类器，输出平均结果

如把猫的图片复制四遍，包括两个镜像版本。如取中心的crop，然后取四个角落的crop，通过分类器来运行它

第1个和第3个是中心crop，第2个和第4个是四个角落的crop。把这些加起来会有10种不同的图像的crop，命名为10-crop。通过分类器来运行这十张图片，然后对结果进行平均

集成的一个大问题是需要保持所有这些不同的神经网络，占用了更多的计算机内存。multi-crop，只保留一个网络，不会占用太多的内存，但仍然会让运行时间变慢
